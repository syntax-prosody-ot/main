/**
 * Functions that handle automatic syntactic tree generation
 * on the html interface
 */

//Getter function that helps with terminal string generation
function getStringsList() {
    return genStringsList;
}


/** Helper function for generating syntactic trees
 *  Called by genTerminalStrings() which is called by autoGenInputTree()
 */
function addFixedTerminalStringsToTable(){
    var length = spotForm.inputToGenAuto.length;
    if(length === undefined) {
        length = 1;
    }
    var inputString = spotForm.inputToGenAuto.value;
    var fixedStringList = [];
    

    for(var i=0; i<length; i++){
        if(length > 1) {
            inputString = spotForm.inputToGenAuto[i].value;
        }
        if(inputString !== "") {
            fixedStringList.push(inputString);
        }
    }
    if(fixedStringList.length > 0) {
        displayStringsTable(fixedStringList);
        genStringsList = fixedStringList;
    }
}


/**
 * CALLED BY "GENERATE TREES"
 * Functions that handle generation and display of syntactic trees 
 * from user-specifications on the interface.
 */

// Adds input field so user can add another terminal string
function addTerminalString(){
    var length = spotForm.inputToGenAuto.length;
    if(length === undefined) {
        length = 1;
    }
    var newLength = length + 1;
    length = length.toString();
    newLength = newLength.toString();
    document.getElementById('str'+length).insertAdjacentHTML('afterend', "<p id='str"+newLength+"'>String of terminals "+newLength+": <input type='text' name='inputToGenAuto'></p>");
    document.getElementById('autoDoneMessage').style.display = 'none';
}

 // Display tables of automatically generated syntactic trees
function displayTable(sTreeList) {
    var treeTable = treeToTable(sTreeList);
    document.getElementById('autoTreeBox').innerHTML += treeTable;
}

// Helper for displayTable and thus autoGenInputTree:
// A function to create an html table from sTreeList, the list of syntactic trees
function treeToTable(sTreeList) {
    var htmlChunks = ['<table class="auto-table"><tbody>'];
    var i = 1;
    for(var s in sTreeList) {
        var parTree = parenthesizeTree(sTreeList[s]);
        htmlChunks.push('<tr>');
        htmlChunks.push('<td>' + i + "." + '</td>');
        htmlChunks.push('<td>' + parTree + '</td>');
        htmlChunks.push('</tr>');
        i++;
    }
    htmlChunks.push('</tbody></table>');
    return htmlChunks.join('');
}

function makeAndDisplaySTrees(){
    document.getElementById('autoDoneMessage').style.display = 'inline-block';
    autoGenInputTree();
    document.getElementById('autoTreeArea').style.display = 'block';
    document.getElementById('syntax-tree-switch').checked = true;
    document.getElementById('syntax-switch-text').innerHTML = 'Hide syntactic trees';
}


var sTreeList;
window.getAutoSTreeList = function(){
    return sTreeList;
}

/**
 * Function that automatically generates input syntactic trees
 * from user input on the interface (interface1.html)
 * 
 * Called by: makeAndDisplaySTrees()
 * 
 * Calls: 
 * - genTerminalStrings()
 * - getStringsList()
 * - displayTable()
 * 
 * Modifies sTreeList
 */
function autoGenInputTree() {
    genTerminalStrings();
    var strings = getStringsList();	//this is both fixed strings and strings generated by combinations/permutations
    var length = strings.length;

    sTreeList = undefined;
    document.getElementById('autoTreeBox').innerHTML = "";

    for(var i=0; i<length; i++){
        var inputString = strings[i];

        // allow adjuncts and remove mirror images
        var autoInputOptions = {};
        var optionBox = spotForm.autoInputOptions;
        for(var j = 0; j < optionBox.length; j++) {
            if(optionBox[j].value == "noAdjuncts" || optionBox[j].value == "noBarLevels") {
                autoInputOptions[optionBox[j].value] =! optionBox[j].checked;
            }
            else {
                autoInputOptions[optionBox[j].value]=optionBox[j].checked;
            }
        }

        // head requirements
        var headReq = document.getElementById('head-req').value;
        if(headReq !== 'select') {
            var headSideVal = headReq;
        }
        autoInputOptions.headSide = headSideVal;

        // add XP clitics directly under root
        if(document.getElementById('add-clitics').checked) {
            var addCliticsVal = document.getElementById('add-clitics').value;
            if(document.getElementById('add-clitics-left').checked) {
                addCliticsVal = 'left';
            }
        }
        autoInputOptions.addClitics = addCliticsVal;

        // root, recursive terminal, category
        autoInputOptions.rootCategory = spotForm['autoInputOptions-rootCategory'].value;
        autoInputOptions.recursiveCategory = spotForm['autoInputOptions-recursiveCategory'].value;
        autoInputOptions.terminalCategory = spotForm['autoInputOptions-terminalCategory'].value;

        if(autoInputOptions.recursiveCategory === 'x0' || autoInputOptions.noUnary){
            autoInputOptions.noAdjacentHeads = false;
        }

        // console.log(autoInputOptions)

        if(inputString !== "") {
            var currSTreeList = sTreeGEN(inputString, autoInputOptions);
            displayTable(currSTreeList);
            if(sTreeList) {
                sTreeList = sTreeList.concat(currSTreeList);
            }
            else {
                sTreeList = currSTreeList;
            }
        }
    }
    //console.log(sTreeList)
}