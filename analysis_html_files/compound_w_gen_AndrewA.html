<html>
<head>
	<title>SPOT investigation: recursive phis and ws</title>

	<link rel="stylesheet" type="text/css" href="../spot.css">

	<script src="../lib/jszip.min.js"></script>
	

	<!-- to keep spot.js in sync with the codebase make sure to run jsbuild.sh after making any changes to javascript files in the main directory or in the constraints sub-directory
	(open a terminal, cd into the main directory, type ./jsbuild.sh and hit enter) -->
	<script src="../build/spot.js"></script>	

				
</head>

<body style="padding-left: 5%; padding-right: 5%; padding-top: 20px">
	<h2>GENerating inputs</h2>
	<pre id="results-container"></pre>

<script>
	// ---- Variables that need to be customized ----
	
	// var inputGenOptions = {rootCategory: 'xp', recursiveCategory: 'xp', terminalCategory:'x0', syntactic: true};
	// var autoSTreePairs = GEN({}, 'a b c', inputGenOptions);
	// var sTreeList = autoSTreePairs.map(x=>x[1]);
	// var noX0Sisters = sTreeList.filter(x => !x0Sisters(x, 'x0'));
	// var binaryBrTrees = sTreeList.filter(x => !ternaryNodes(x, 2));
	// var maxTTrees = sTreeList.filter(x => !x0Sisters(x, 'x0') && !ternaryNodes(x, 2));
    var words = ['F', 'FF', 'FFF', 'FFFF'];
    var terminalStrings = [];

    //Two word compound strings
    for(var i = 0; i<words.length; i++){
        for(var j = 0; j < words.length; j++){
            var tString = [words[i], words[j]].join(' ');
            terminalStrings.push(tString);
        }
    }

    //Three word compound strings
    for(var i = 0; i<words.length; i++){
        for(var j = 0; j < words.length; j++){
            for(var k = 0; k < words.length; k++){
                var tString = [words[i], words[j], words[k]].join(' ');
                terminalStrings.push(tString);
            }
        }
    }
    
    //There are a total of 16 (4^2) + 64 (4^3) = 80 
    console.log(terminalStrings);


    //Generate all the possible syntactic trees for these terminal strings.
    var sTreeOptions = {
        rootCategory: 'x0', recursiveCategory: 'x0', 
        maxBranching: 2, noAdjacentHeads: false, noUnary:true
    };

    var myTrees = [];

    // Something is going wrong here: getting doubles of everything
    for(var i = 0; i<terminalStrings.length; i++){
        var currString = terminalStrings[i];
        //console.log(currString);
        var currTrees = sTreeGEN(currString, sTreeOptions);
        //console.log(currTrees);
        myTrees.push(currTrees);
    }

    sTreeList = myTrees.flat();
    console.log("Number of sTrees: ", sTreeList.length);
    for(var i in sTreeList){
        console.log(parenthesizeTree(sTreeList[i]));
    }


	/*Constraint sets.*/
    var starStruc = ['starCat-phi', 'starCat-w'];
    var con1 = ['matchSP-x0', 'matchPS-w', 'binMaxHead-w', 'binMinBranches-w', 'binMinBranches-phi', 'equalSistersAdj'];

	
	/*A list of names for constraint sets.*/
    var conNames = ['con1'];
	
	//Candidate sets are generated with the options below.
	var output_gen_options = {rootCategory: 'phi', recursiveCategory: 'phi-w', terminalCategory: 'w'};
	
	
	// ---- Functions that don't necessarily need to be customized ----
	
	/*Function that concatenates a bunch of tableaux for various candidate sets into one large tableau. It does not need to be modified if you are only comparing different constraint sets. But it can be modified to deal with your particular analysis. For example, to consider multiple possible input syntaxes, you can add an outer for-loop to iterate over the different tree sets, as well as interating over the trees in each set.*/
    function makeTableauCsvs(consName) {
        var csvSegs = [];	//List to accumulate tableaux in

        var candSets = [];
        for(var s in sTreeList){
            var sTree = sTreeList[s];
            var cs = GEN(sTree, '', output_gen_options);
            //TODO: add the missing (a [.w b c]), ([.w a [.w b c]])
            var leaves = getLeaves(sTree);
            if(leaves.length === 3){
                var m1 = {id:'root', cat:'phi', children:[
                    {
                        id:leaves[0].id,
                        cat:'w'
                    },
                    {
                        id:'intermed',
                        cat:'w',
                        children:[
                            {
                                id:leaves[1].id,
                                cat:'w'
                            },
                            {
                                id:leaves[2].id,
                                cat:'w'
                            }
                        ]
                    }
                ]};
                var m2 = {id:'root', cat:'phi', children:[ {id:'intermed', cat:'w', children:[
                    {
                        id:leaves[0].id,
                        cat:'w'
                    },
                    {
                        id:'intermed',
                        cat:'w',
                        children:[
                            {
                                id:leaves[1].id,
                                cat:'w'
                            },
                            {
                                id:leaves[2].id,
                                cat:'w'
                            }
                        ]
                    }
                ]}]};
                cs.push([sTree, m1]);
                cs.push([sTree, m2]);
            }
            candSets.push(cs);
        }
		for(var i in candSets){
			//Make the tableau using the makeTableau function (defined in tableauMaker.js)
			var tabl = makeTableau(candSets[i], window[consName], {showHeads:true});
			writeTableau(tabl);
			revealNextSegment();
			lastSegmentId++;
		}


    }
	
	/*This function executes automatically when the page is reloaded. It calls all the other functions.*/
    function runDemo() {
	//Iterate over the different constraint sets. Make a tableau for each one.
		for(var i = 0; i<conNames.length; i++){
			makeTableauCsvs(conNames[i]);
		}
    }
    
    /*Utilities for saving files.*/
    function saveAs(blob, name) {
        var a = document.createElement("a");
        a.display = "none";
        a.href = URL.createObjectURL(blob);
        a.download = name;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
    }
   
    function saveTextAs(text, name) {
        saveAs(new Blob([text], {type: "text/csv", encoding: 'utf-8'}), name);
    }
	


</script>

</body>

</html>
