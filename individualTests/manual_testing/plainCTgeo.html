<html>
<head>
	<title>Nick's File (1.17.2018)</title>

	<link rel="stylesheet" type="text/css" href="../../spot.css">

	<!-- to keep spot.js in sync with the codebase make sure to run jsbuild.sh after making any changes to javascript files in the main directory or in the constraints sub-directory
	(open a terminal, cd into the main directory, type ./jsbuild.sh and hit enter) -->
	<script src="../../build/spot.js"></script>
	
</head>

<body style="padding-left: 5%; padding-right: 5%; padding-top: 20px">
	<h2>Nick's File (1.17.2018)</h2>
	<pre id="results-container"></pre>

	<!--  Load the tree files that you need  -->
	<script src="../../trees/japaneseAccent_sTrees.js"></script>
	
	<script>
	//Now we're in the JavaScript section
	
		/*Let's list our constraints: get the names out of the constraint definition js files
		Category name should be separated from constraint name by -
		*/
		var constraintSet = ['matchXPmax-xp', 'matchSP-xp', 'matchPS_nmin-phi', 'matchPS-phi', 'binMinBranches-phi', 'binMaxBranches-phi', 'binMax2Words-phi', 'equalSistersAdj-phi', 'strongStart_Elfner-w', 'noPostAccW', 'accentAsHead-phi', 'matchSP_nmin-xp', 'equalSistersAdj_2-phi', 'noLapseL', 'nonRec1-phi'];
	
	
	var lsCon = ['matchLexSP-xp', 'matchSP-xp', 'matchPS-phi', 'binMinBranches-phi', 'binMaxBranches-phi', 'binMax2Words-phi', 'equalSistersAdj-phi', 'strongStart_Elfner-w'];
	
	var groupCon = ["group", "globalGroup", "splitApart", 'binMaxBranches-phi'];

	var sogoCon = ["group", "groupMin", "splitNMC", "splitNMCmin"];

//MY FOREST

	var tri_Heads = {
    "id": "CP1",
    "cat": "xp",
    "children": [
        {
            "id": "X",
            "cat": "x0"
        },
        {
            "cat": "xp",
            "id": "XP_4",
            "children": [
                {
                    "id": "Y",
                    "cat": "x0"
                },
                {
                    "id": "Z",
                    "cat": "x0"
                }
            ]
        }
    ]
	};
	var tri_Heads_CS = GEN(tri_Heads, 'X Y Z', {obeysExhaustivity:true});
	
	var kvar_Heads = {
    "id": "CP1",
    "cat": "xp",
    "children": [
        {
            "id": "W",
            "cat": "x0"
        },
        {
            "cat": "xp",
            "id": "XP_6",
            "children": [
                {
                    "id": "X",
                    "cat": "x0"
                },
                {
                    "cat": "xp",
                    "id": "XP_5",
                    "children": [
                        {
                            "id": "Y",
                            "cat": "x0"
                        },
                        {
                            "id": "Z",
                            "cat": "x0"
                        }
                    ]
                }
            ]
        }
    ]
	};
	var kvar_Heads_CS = GEN(kvar_Heads, 'W X Y Z', {obeysExhaustivity:true});
	
	var kvin_Heads = {
    "id": "CP1",
    "cat": "xp",
    "children": [
        {
            "id": "V",
            "cat": "x0"
        },
        {
            "cat": "xp",
            "id": "XP_8",
            "children": [
                {
                    "id": "W",
                    "cat": "x0"
                },
                {
                    "cat": "xp",
                    "id": "XP_7",
                    "children": [
                        {
                            "id": "X",
                            "cat": "x0"
                        },
                        {
                            "cat": "xp",
                            "id": "XP_6",
                            "children": [
                                {
                                    "id": "Y",
                                    "cat": "x0"
                                },
                                {
                                    "id": "Z",
                                    "cat": "x0"
                                }
                            ]
                        }
                    ]
                }
            ]
        }
    ]
	};
	var kvin_Heads_CS = GEN(kvin_Heads, 'V W X Y Z', {obeysExhaustivity:true});
	
	var ses_Heads = {
    "id": "CP1",
    "cat": "xp",
    "children": [
        {
            "id": "U",
            "cat": "x0"
        },
        {
            "cat": "xp",
            "id": "XP_10",
            "children": [
                {
                    "id": "V",
                    "cat": "x0"
                },
                {
                    "cat": "xp",
                    "id": "XP_9",
                    "children": [
                        {
                            "id": "W",
                            "cat": "x0"
                        },
                        {
                            "cat": "xp",
                            "id": "XP_8",
                            "children": [
                                {
                                    "id": "X",
                                    "cat": "x0"
                                },
                                {
                                    "cat": "xp",
                                    "id": "XP_7",
                                    "children": [
                                        {
                                            "id": "Y",
                                            "cat": "x0"
                                        },
                                        {
                                            "id": "Z",
                                            "cat": "x0"
                                        }
                                    ]
                                }
                            ]
                        }
                    ]
                }
            ]
        }
    ]
	};
	var ses_Heads_CS = GEN(ses_Heads, 'U V W X Y Z', {obeysExhaustivity:true});
	
	var klasika = {
    "id": "vP",
    "cat": "xp",
    "children": [
        {
            "id": "V",
            "cat": "x0"
        },
        {
            "cat": "xp",
            "id": "VP",
            "children": [
                {
                    "cat": "xp",
                    "id": "NP1",
                    "children": [
                        {
                            "id": "N",
                            "cat": "x0"
                        }
                    ]
                },
                {
                    "cat": "xp",
                    "id": "NP2",
                    "children": [
                        {
                            "id": "N_1",
                            "cat": "x0"
                        }
                    ]
                }
            ]
        }
    ]
	};
	var klasika_CS = GEN(klasika, 'V N N', {obeysExhaustivity:true});
	
	var abcde = {
    "id": "WP",
    "cat": "xp",
    "children": [
        {
            "id": "A",
            "cat": "x0"
        },
        {
            "cat": "xp",
            "id": "XP",
            "children": [
                {
                    "cat": "xp",
                    "id": "YP",
                    "children": [
                        {
                            "id": "B",
                            "cat": "x0"
                        },
                        {
                            "id": "C",
                            "cat": "x0"
                        }
                    ]
                },
                {
                    "cat": "xp",
                    "id": "ZP",
                    "children": [
                        {
                            "id": "D",
                            "cat": "x0"
                        },
                        {
                            "id": "E",
                            "cat": "x0"
                        }
                    ]
                }
            ]
        }
    ]
	};
	var abcde_CS = GEN(abcde, 'A B C D E', {obeysExhaustivity:true});
	
		function runDemo() {
			writeTableau(makeTableau(klasika_CS, sogoCon));
			revealNextSegment();
			lastSegmentId++;
			
				writeTableau(makeTableau(abcde_CS, sogoCon));
				revealNextSegment();
				lastSegmentId++;
			
			
				writeTableau(makeTableau(tri_Heads_CS, groupCon));
				revealNextSegment();
				lastSegmentId++;
				
				writeTableau(makeTableau(kvar_Heads_CS, groupCon));
				revealNextSegment();
				lastSegmentId++;
				
				writeTableau(makeTableau(kvin_Heads_CS, groupCon));
				revealNextSegment();
				lastSegmentId++;
				
				writeTableau(makeTableau(ses_Heads_CS, groupCon));
				revealNextSegment();
				lastSegmentId++;
				
			};
		
		
		
	function lexHelper(sParent, pTree, sCat)
	{
	if(sParent.cat === sCat)
		logreport.debug("\tSeeking match for "+sParent.id + " in tree rooted in "+pTree.id);
	var vcount = 0;
	
	if((sParent.cat === sCat) && !hasMatch(sParent, pTree) && pTree.lex){
		vcount++;
		logreport.debug("\tVIOLATION: "+sParent.id+" has no match!");
	} 
		
	if(sParent.children){	
		for(var i = 0; i < sParent.children.length; i++)
		{
			var sChild = sParent.children[i];
			vcount += lexHelper(sChild, pTree, sCat);
		}
	}
	
	return vcount;
	};
	
	function matchLexPS(sTree, pParent, pCat)
	{
		return lexHelper(pParent, sTree, pCat);
	};
			
	function noPostAccW(s, pParent, c){
			var vCount = 0;
			if(pParent.children && pParent.children.length)
			{
				for(var i=0; i < pParent.children.length; i++){
					var child = pParent.children[i];
					if((i<pParent.children.length-1) && hasAccFeature(child))
					{
						var sister = pParent.children[i+1];
						if(sister.cat == "w")
						{
							vCount++;
						}
					}
					vCount += noPostAccW(s, child, c);
				}
			}
			return vCount;
		};
	
	function hasAccFeature(pTree)
	{
			var a = false;
			var leaves = getLeaves(pTree);
			if(!pTree.children)
			{
				if(pTree.accent == "a")
				{
					var a = true;
				};
			};
			for(var i = 0; i < leaves.length; i++)
			{
				var leaf = leaves[i];
				//I'm being lazy and assuming accent is already specified! Should change this later.
				if(leaf.accent == "a")
				{
					var a = true;
					break;
				};
			};
			return a;
		};
		
	function myNoLapse(s, pParent, c){
			var vCount = 0;
			if(pParent.children && pParent.children.length)
			{
				for(var i=0; i < pParent.children.length; i++){
					var child = pParent.children[i];
					if((i<pParent.children.length-1))
					{
						var sister = pParent.children[i+1];
						if(hasAccFeature(child) && (sister.cat == "w") && (sister.accent == "u"))
						{
							vCount++;
						}
					}
					vCount += myNoLapse(s, child, c);
				}
			}
			return vCount;
		};
		
	/*function prosNonMin(pTree)
	{
		var answer = false;
		if(pTree.children.length)
		{
			for(var i = 0; i < pTree.children.length; i++)
			{
				var child = pTree.children[i];
				if(child.cat == pTree.cat)
				{
					var answer = true;
					break;
				};
			};
		};
		return answer;
	};
	
	function unequalMinimality(p1,p2)
	{
		var um = false;
		if((prosNonMin(p1) && !prosNonMin(p2)) || (!prosNonMin(p1) && prosNonMin(p2)))
		{
			var um = true;
		};
		return um;
	};*/
	
	//I'm being lazy: this will only work properly
	//if the only CP node in the tree is the ROOT node!
	//It will also work if the tree is just rooted in XP.
	function matchXPmax(sParent, pTree, sCat)
	{
		var vcount = 0;
		if((sParent.cat === 'xp') && !hasMatch(sParent, pTree)){
			vcount++;
			logreport.debug("\tVIOLATION: "+sParent.id+" has no match!");
		}
		if(((sParent.cat === 'cp') || (sParent.cat === 'clause')) && sParent.children && sParent.children.length)
		{
			for(var i = 0; i  < sParent.children.length; i++)
			{
				var child = sParent.children[i];
				if((child.cat === 'xp') && !hasMatch(child, pTree))
				{
					vcount++;
				};
			};
		};
		return vcount;
	};
	
	function equalSistersAdj_2(s, pparent, c){
		var vCount = 0;
		if(pparent.children && pparent.children.length)
		//pTree is non-terminal
		{
			for(var i=0; i < pparent.children.length; i++){
				var child = pparent.children[i];
				if(i<pparent.children.length-1)
				{
					var sister = pparent.children[i+1];
					if(child.cat != sister.cat)
					{
						if(hasPhiChild(child) && !hasPhiChild(sister))
						{
							vCount++;
						};
						if(!hasPhiChild(child) && hasPhiChild(sister))
						{
							vCount++;
						};
					}
				}
				vCount += equalSistersAdj_2(s, child, c);
			}
		}
		return vCount;
	};
		
	function hasPhiChild(p)
	{
		var answer = false;
		if(p.children && p.children.length)
		{
			for(var i = 0; i < p.children.length; i++)
			{
				var child = p.children[i];
				if(child.cat == "phi")
				{
					var answer = true;
					break;
				};
			};
		};
		return answer;
	};	
		
	function noLoverR(s, pParent, c){
		var vCount = 0;
		//i=0, phi=1, w=2
		//so "<" means "outranks on the hierarchy"
		var prosHi = ["i", "phi", "w"];
		if(pParent.children && pParent.children.length)
		//pTree is non-terminal
		{
			for(var i=0; i < pParent.children.length; i++){
				var child = pParent.children[i];
				if(i<pParent.children.length-1)
				{
					var sister = pParent.children[i+1];
					if(prosHi.indexOf(child) < prosHi.indexOf(sister))
					{
						vCount++;
					};
				}
				vCount += noLoverR(s, child, c);
			}
		}
		return vCount;
	};
	
	function noRoverL(s, pParent, c){
		var vCount = 0;
		//i=0, phi=1, w=2
		//so "<" means "outranks on the hierarchy"
		var prosHi = ["i", "phi", "w"];
		if(pParent.children && pParent.children.length)
		//pTree is non-terminal
		{
			for(var i=0; i < pParent.children.length; i++){
				var child = pParent.children[i];
				if(i<pParent.children.length-1)
				{
					var sister = pParent.children[i+1];
					if(prosHi.indexOf(child) > prosHi.indexOf(sister))
					{
						vCount++;
					};
				}
				vCount += noLoverR(s, child, c);
			}
		}
		return vCount;
	};

	function matchPS_nmin(sTree, pParent, pCat)
	{
		return matchSP_nmin(pParent, sTree, pCat);
	};
	
	function matchSP_nmin(sParent, pTree, sCat)
	{
		if(sParent.cat === sCat)
			logreport.debug("\tSeeking match for "+sParent.id + " in tree rooted in "+pTree.id);
		var vcount = 0;
	
		if((sParent.cat === sCat) && !hasMatch(sParent, pTree)){
			if(sParent.children.length >= 2)
			{
				vcount++;
				logreport.debug("\tVIOLATION: "+sParent.id+" has no match!");
			}
		}
		
		if(sParent.children){	
			for(var i = 0; i < sParent.children.length; i++)
			{
				var sChild = sParent.children[i];
				vcount += matchSP_nmin(sChild, pTree, sCat);
			}
		}
		return vcount;
	};
	
	function matchLexSP(sParent, pTree, sCat)
	{
		if((sParent.cat === sCat) && sParent.lex)
			logreport.debug("\tSeeking match for "+sParent.id + " in tree rooted in "+pTree.id);
		var vcount = 0;
	
		if((sParent.cat === sCat) && !hasMatch(sParent, pTree) && sParent.lex){
			vcount++;
			logreport.debug("\tVIOLATION: "+sParent.id+" has no match!");
		} 
		
		if(sParent.children){	
			for(var i = 0; i < sParent.children.length; i++)
			{
				var sChild = sParent.children[i];
				vcount += matchLexSP(sChild, pTree, sCat);
			}
		}
	
		return vcount;
	};
	
	function hasLexMatch(sNode, pTree)
	{
		var sLeaves = getLeaves(sNode);
		if(catsMatch(sNode.cat, pTree.cat) && sameIds(getLeaves(pTree), sLeaves) && pTree.lex)
		// the current prosodic node is the match, both for category and for terminals
		{
			logreport.debug("\tMatch found: "+pTree.id);
			return true;
		}
	
		// If the current prosodic node is NOT the match:
	
		else if(!pTree.children || pTree.children.length===0)
		// current node is terminal
			return false;	

		else
		//the current prosodic node is non-terminal (has children)
		{
			for(var i = 0; i < pTree.children.length; i++)
			//check each child to see if the match exists in the subtree rooted in that child
			{
				var child = pTree.children[i];
				if(hasLexMatch(sNode, child))
					return true;
			}
			return false;
		}
	
	}
	

	
	//COMMAND THEORY
	function isInArray(myArray, x)
	{
		var answer = false;
		for(var i = 0; i < myArray.length; i++)
		{
			if(x == myArray[i])
			{
				answer = true;
			}
		}
		return answer;
	};

	function getNodes(myTree)
	{
		var nodes = [];
		nodes.push(myTree);
		if(myTree.children && myTree.children.length)
		{
			for(var x = 0; x < myTree.children.length; x++)
			{
				var xNodes = getNodes(myTree.children[x]);
				for(var y = 0; y < xNodes.length; y++)
				{
					nodes.push(xNodes[y]);
				}
			}
		}
		return nodes;
	};

	// x immediately dominates y
	function imDom(x,y)
	{
		var check = false;
		if(x.children && x.children.length)
		{
			for(var i = 0; i < x.children.length; i++)
			{
				var currentKid = x.children[i];
				if(currentKid == y)
				{
					var check = true;
				}
			}
		};
		return check;
	};

	// Intended to replace imDom
	function isParentOf(x,y){
		return (x.children || []).indexOf(y) >= 0;
	}

	//Returns parent of goal-node in within tree, if one exists. Else returns false.
	function getParent(myTree,goal)
	{
		var par = false;
		if(imDom(myTree, goal) == true)
		{
			par = myTree;
		}
		else
		{
			if(myTree.children && myTree.children.length)
			{
				for(var j = 0; j < myTree.children.length; j++)
				{
					var nextNode = myTree.children[j];
					if(getParent(nextNode, goal) != "")
					{
						par = getParent(nextNode, goal);
					}
				}
			}
		}
		return par;
	};

	//Returns the non-silent terminals c-commanded by node x within tree.
	function commands(myTree,x)
	{
		var domain = [];
		var xParent = getParent(myTree,x);
		if(hasParent(myTree,x) && (xParent.children.length > 1))
		{
			for(var i = 0; i < xParent.children.length; i++)
			{
				var current = xParent.children[i];
				if(current != x)
				{
					var currentNodes = getNodes(current);
					for(var j = 0; j < currentNodes.length; j++)
					{
						var z = currentNodes[j];
						if(!z.silent && !z.children)
						{
							domain.push(z);
						}
					}
				}
			}
		};
		return domain;
	};

	function hasParent(myTree, x)
	{
		if(getParent(myTree, x) == "false")
		{
			return false;
		}
		else
		{
			return true;
		}
	};

	function getPhis(pTree)
	{
		var phiArray = [];
		var nodes = getNodes(pTree);
		for(var i = 0; i < nodes.length; i++)
		{
			var current = nodes[i];
			if(current.cat == "phi")
			{
				phiArray.push(current);
			}
		};
		return phiArray;
	};

	function phiMates(ptree,x,y)
	{
		var answer = false;
		var phis = getPhis(ptree);
		for(var i = 0; i < phis.length; i++)
		{
			var currentPhi = phis[i];
			var nodes = currentPhi.children;
			var hasX = false;
			var hasY = false;
			for(var j = 0; j < nodes.length; j++)
			{
				var k = nodes[j];
				if(k.id == x.id)
				{
					var hasX = true;
				}
				if(k.id == y.id)
				{
					var hasY = true;
				}
				if(hasX && hasY)
				{
					break;
				}
			};
			if(hasX && hasY)
			{
				var answer = true;
				break;
			}
		};
		return answer;
	};

	function sharePhi(ptree,x,y)
	{
		var answer = false;
		var phis = getPhis(ptree);
		for(var i = 0; i < phis.length; i++)
		{
			var currentPhi = phis[i];
			var nodes = getNodes(currentPhi);
			var hasX = false;
			var hasY = false;
			for(var j = 0; j < nodes.length; j++)
			{
				var k = nodes[j];
				if(k.id == x.id)
				{
					var hasX = true;
				}
				if(k.id == y.id)
				{
					var hasY = true;
				}
				if(hasX && hasY)
				{
					break;
				}
			};
			if(hasX && hasY)
			{
				var answer = true;
				break;
			}
		};
		return answer;
	};

	function group(sTree,pTree)
	{
		var vcount = 0;
		var sLeaves = getLeaves(sTree);
		for(var i = 0; i < sLeaves.length; i++)
		{
			var currentLeaf = sLeaves[i];
			var comSet = commands(sTree,currentLeaf);
			for(var j = 0; j < comSet.length; j++)
			{
				var currentCommandee = comSet[j];
				if(!sharePhi(pTree,currentLeaf,currentCommandee))
				{
					vcount++;
				}
			}
		}
		return vcount;
	};

	function groupMin(sTree,pTree)
	{
		var vcount = 0;
		var sLeaves = getLeaves(sTree);
		for(var i = 0; i < sLeaves.length; i++)
		{
			var currentLeaf = sLeaves[i];
			var comSet = commands(sTree,currentLeaf);
			for(var j = 0; j < comSet.length; j++)
			{
				var currentCommandee = comSet[j];
				if(!phiMates(pTree,currentLeaf,currentCommandee))
				{
					vcount++;
				}
			}
		}
		return vcount;
	};

	//Assumes x is a non-silent leaf. Returns next non-silent leaf.
	function nextLeaf(tree,x)
	{
		var next = [];
		var leaves = getLeaves(tree);
		for(var i = 0; i < leaves.length-1; i++)
		{
			if(leaves[i] == x)
			{
				var j = leaves[i+1];
				next.push(j);
				break;
			}
		}
		return next;
	};

	//NB: ASSUMES x AND y ARE TERMINALS! Will return false if one of the nodes is non-terminal, even if it actually c-commands the other.
	function mutualNonCommand(tree,x,y)
	{
		var cx = commands(tree,x);
		var cy = commands(tree,y);
		if(!isInArray(cx,y) && !isInArray(cy,x))
		{
			return true;
		}
		else
		{
			return false;
		};
	};
	
	//NB: ASSUMES x AND y ARE TERMINALS! Will return false if one of the nodes is non-terminal, even if it actually c-commands the other.
	function siblings(tree,x,y)
	{
		var cx = commands(tree,x);
		var cy = commands(tree,y);
		if(isInArray(cx,y) && isInArray(cy,x))
		{
			return true;
		}
		else
		{
			return false;
		};
	};

	function splitNMC(sTree,pTree)
	{
		var vcount = 0;
		var sLeaves = getLeaves(sTree);
		for(var i = 0; i < sLeaves.length; i++)
		{
			var current = sLeaves[i];
			if(nextLeaf(sTree,current).length)
			{
				var next = nextLeaf(sTree,current)[0];
				if(mutualNonCommand(sTree,current,next) && sharePhi(pTree,current,next))
				{
					vcount++;
				}
			}
		}
		return vcount;
	};

	function splitNMCmin(sTree,pTree)
	{
		var vcount = 0;
		var sLeaves = getLeaves(sTree);
		for(var i = 0; i < sLeaves.length; i++)
		{
			var current = sLeaves[i];
			if(nextLeaf(sTree,current).length)
			{
				var next = nextLeaf(sTree,current)[0];
				if(mutualNonCommand(sTree,current,next) && phiMates(pTree,current,next))
				{
					vcount++;
				}
			}
		}
		return vcount;
	};

	function adjacent(tree,x,y)
	{
		var leaves = getLeaves(tree);
		var xindex = leaves.indexOf(x);
		var yindex = leaves.indexOf(y);
		if(Math.abs(xindex-yindex) === 1)
		{
			return true;
		}
		else
		{
			return false;
		};
	};

	function localGroup(sTree,pTree)
	{
		var vcount = 0;
		var sLeaves = getLeaves(sTree);
		for(var i = 0; i < sLeaves.length; i++)
		{
			var currentLeaf = sLeaves[i];
			var comSet = commands(sTree,currentLeaf);
			for(var j = 0; j < comSet.length; j++)
			{
				var currentCommandee = comSet[j];
				
				//Are they adjacent?
				if(adjacent(sTree,currentLeaf,currentCommandee))
				{
					var phiSet = getPhis(pTree);
					for(var k = 0; k < phiSet.length; k++)
					{
						if(pCorDom(phiSet[k],currentLeaf) && !pCorDom(phiSet[k],currentCommandee))
						{
							vcount++;
						};
						if(!pCorDom(phiSet[k],currentLeaf) && pCorDom(phiSet[k],currentCommandee))
						{
							vcount++;
						};
					};
				};	
			}
		}
		return vcount;
	};
	
	function globalGroup(sTree,pTree)
	{
		var vcount = 0;
		var sLeaves = getLeaves(sTree);
		for(var i = 0; i < sLeaves.length; i++)
		{
			var currentLeaf = sLeaves[i];
			var comSet = commands(sTree,currentLeaf);
			for(var j = 0; j < comSet.length; j++)
			{
				var currentCommandee = comSet[j];
				
					var phiSet = getPhis(pTree);
					for(var k = 0; k < phiSet.length; k++)
					{
						if(pCorDom(phiSet[k],currentLeaf) && !pCorDom(phiSet[k],currentCommandee))
						{
							vcount++;
						};
						if(!pCorDom(phiSet[k],currentLeaf) && pCorDom(phiSet[k],currentCommandee))
						{
							vcount++;
						};
					};
				
			}
		}
		return vcount;
	};
	
	//Assign a violation if an adjacent non-c-pair doesn't have
	//each word contained in at least one phi that excludes the other.
	function splitApartC(sTree,pTree)
	{
		var vcount = 0;
		var sLeaves = getLeaves(sTree);
		for(var i = 0; i < sLeaves.length; i++)
		{
			var current = sLeaves[i];
			if(nextLeaf(sTree,current).length)
			{
				var next = nextLeaf(sTree,current)[0];
				if(mutualNonCommand(sTree,current,next))
				{
					var phiSet = getPhis(pTree);
					var pNextOnly = false;
					var pCurrentOnly = false;
					for(var k = 0; k < phiSet.length; k++)
					{
						if(pCorDom(phiSet[k],current) && !pCorDom(phiSet[k],next))
						{
							pCurrentOnly = true;
						};
						if(pCorDom(phiSet[k],next) && !pCorDom(phiSet[k],current))
						{
							pNextOnly = true;
						};
					};
					if(!pNextOnly || !pCurrentOnly)
					{
						vcount++
					};
				}
			}
		}
		return vcount;
	};
	
	
	//Assign a violation if an adjacent non-c-pair doesn't have
	//each word contained in at least one phi that excludes the other.
	function splitApart(sTree,pTree)
	{
		var vcount = 0;
		var sLeaves = getLeaves(sTree);
		for(var i = 0; i < sLeaves.length; i++)
		{
			var current = sLeaves[i];
			if(nextLeaf(sTree,current).length)
			{
				var next = nextLeaf(sTree,current)[0];
				if(mutualNonCommand(sTree,current,next))
				{
					var phiSet = getPhis(pTree);
					var pNextOnly = false;
					var pCurrentOnly = false;
					for(var k = 0; k < phiSet.length; k++)
					{
						if(pCorDom(phiSet[k],current) && !pCorDom(phiSet[k],next))
						{
							pCurrentOnly = true;
						};
						if(pCorDom(phiSet[k],next) && !pCorDom(phiSet[k],current))
						{
							pNextOnly = true;
						};
					};
					if(!pNextOnly)
					{
						vcount++;
					};
					if(!pCurrentOnly)
					{
						vcount++;
					};
				}
			}
		}
		return vcount;
	};
	
	function mutualSplit(sTree,pTree)
	{
		var vcount = 0;
		var sLeaves = getLeaves(sTree);
		for(var i = 0; i < sLeaves.length; i++)
		{
			var current = sLeaves[i];
			if(nextLeaf(sTree,current).length)
			{
				var next = nextLeaf(sTree,current)[0];
				if(!siblings(sTree,current,next))
				{
					var phiSet = getPhis(pTree);
					var pNextOnly = false;
					var pCurrentOnly = false;
					for(var k = 0; k < phiSet.length; k++)
					{
						if(pCorDom(phiSet[k],current) && !pCorDom(phiSet[k],next))
						{
							pCurrentOnly = true;
						};
						if(pCorDom(phiSet[k],next) && !pCorDom(phiSet[k],current))
						{
							pNextOnly = true;
						};
					};
					if(!pNextOnly)
					{
						vcount++;
					};
					if(!pCurrentOnly)
					{
						vcount++;
					};
				}
			}
		}
		return vcount;
	};
	
	//for x a prosodic node, y a syntactic node
	//does x dominate the p-correspondent of y?
	function pCorDom(x,y)
	{
		var answer = false;
		var xLeaves = getLeaves(x);
		for(var i = 0; i < xLeaves.length; i++)
		{
			var cLeaf = xLeaves[i];
			if(cLeaf.id == y.id)
			{
				answer = true;
			};
		};
		return answer;
	};
	
	</script>

</body>

</html>
