<html>
	<head>
		<title>SPOT Interface</title>

		<script src="build/spot.js"></script>
		<script src="./trees/built-in_trees.js"></script>
		<script src="./trees/left_branching_accent_trees_2_3_4_words.js"></script>
		<link rel="stylesheet" type="text/css" href="spot.css">
		<link rel="icon" type="image/x-icon" href="images/favicon.ico">

		<style>
			body {
				margin: 0px;
				font-family: Arial, Helvetica, sans-serif;
			}
			.header {
				background-color: #6d86a3;
				/*border-top: 8px solid white;*/
				/*border-bottom: 1px solid gray;*/
				position: fixed;
				top: 0;
				padding: 5px 80px;
				z-index: 1;
				width: 100%;
				color: #ffffff;
			}
			.header img {
				float: left;
				width: 44px;
				height: 44px;
				margin-right: 20px;
			}
			.header .subtitle {
				/*color: #3A5370;*/
				position: relative;
				top: 12px;
			}
			.below-header {
				padding: 0px 130px;
				position: absolute;
				top: 50px;
			}
			.blue-text {
				color: #07203D;
			}

			body{
				background-color: #d0d8e0;
			}

			div.spotBlock{
				background-color:white;
				padding: 2em;
				padding-top: 1em;
				margin: 2em;
			}

			fieldset:not(.open) > :not(legend) {
				display: none;
			}
			fieldset legend {
				cursor: pointer;
				padding-left: 10px;
				padding-right: 10px;
				border-radius: 3px;
			}
			fieldset legend:hover {
				background-color: #eee;
			}
			.arrow {
				border: solid;
				border-width: 0 3px 3px 0;
				display: inline-block;
				padding: 3px;
			}
			fieldset:not(.open) legend .arrow {
				transform: rotate(45deg);
			}
			fieldset.open legend .arrow {
				transform: rotate(-135deg);
			}
			table.spaceytable td {
				padding:5px
			}
			#treeTableContainer div > * {
				vertical-align: middle;
			}
			#treeTableContainer {
				width: fit-content;
				height: 250px;
				overflow: scroll;
				resize: both;
				border: 1px solid #a9a9a9;
			}
			.inline-block {
				display:inline-block
			}
			.inputContainer {
				width: 100%;
				padding-right: 5%;
				padding-left: 5%;
			}
			.inputContainer input {
				width: 90%;
				text-align: center;
			}
			.catInput {
				font-weight: bold;
				font-size: 12px;
				background-color: #ccc;
			}
			.idInput {
				font-size: 15px;
			}
			.stemSide {
				height: 55px;
			}
			.stemContainer > div.stemSide {
				height: 12px;
			}
			.treeNode {
				display: inline-block;
			}
			.treeNode:hover {
				background-color: #eee;
				cursor: pointer;
			}
			.treeNode.selected {
				background-color: #cdf;
			}
			.treeUI-tree {
				margin-top: 15px;
			}
			button {
				color: #ffffff;
				background-color: #6d86a3;
				border-color: #546D8A;
				border: 1px solid transparent;
				border-radius: 4px;
				cursor: pointer;
				font-size: 14px;
				padding: 4px 8px;
				margin: 5px;
			}
			button:hover {
				background-color: #546D8A;
				border-color: #3A5370;
			}
			button.orange-button {
			    background-color: #f0ad4e;
			    border-color: #eea236;
			}
			button.orange-button:hover {
			    background-color: #ec971f;
			    border-color: #d58512;
			}
			button.submit-button {
				font-size: 16px;
				padding: 8px 20px;
			}
			fieldset {
				margin-top: 10px;
				border-width: 1px;
			}
			fieldset h2 {
				margin: 0px;
			}
			h2 {
				font-size: 20px;
				color: #07203D;
			}
			h3 {
				color: #07203D;
				margin-top: 5px;
			}
			fieldset h3, fieldset p {
				margin: 5px;
				color: #07203D;
				font-weight: normal;
			}
			.constraint-selection-table {
				padding-left: 20px;
				margin-left: 30px;
				width:70%;
				/*table-layout: fixed;*/
				margin-bottom: 8px;
			}

			.constraint-row{
				margin-top: 1em;
				padding-bottom: 8px;
			}

			.constraint-checked .constraint-row:after{
				display:block;
				content: '';
				border-bottom:2px solid #546D8A;
				/* width: 90%; */
			}

			div:not(.constraint-checked) .constraint-row  .constraint-row:after{
				display:none;
			}

			.constraint-row span:not(.content){
				text-align:left;
				display:inline-block;
				/*font-variant: small-caps;
				font-family: "Palatino Linotype", Garamond, serif;
				letter-spacing: 0.07em;*/
				width: 90%;
			}


			.category-row{
				margin-left: 2em;
				display:block;
				padding-bottom: 0.25em;
			}

			.constraint-selection-table:not(.constraint-checked) .category-row{
				display:none;
			}

			.category-selection-div{
				display: inline-block;
				width: 5em;
			}

			.option-selection-div{
				display: inline-block;
				width: 10em;
			}

			.custom-option-div {
				margin-left: 1em;
			}

			.info .content.custom-option-div {
				margin-left: 1.5em;
			}

			.custom-text {
				margin-top: 5px;
				margin-bottom: 5px;
			}

			.custom-text p {
				display: inline;
				margin-left: 0px;
				margin-right: 0px;
			}

			.stree-textarea {
				font-size: 11px;
				width: 100%;
			}
			.info {
				margin-left: 5px;
				font-size: 13px;
				display:inline;
			}
			.info:before {
				display: inline-block;
				content: "i";
				font-family: "Segoe UI";
				font-weight: bold;
				border: 1px solid;
				border-radius: 1em;
				padding-right: 0.4em;
				padding-left: 0.4em;
				cursor: pointer;
				color: #07C;
				text-align: right;
			}
			.info .content {
				display: none;
				margin-left: 5px;
				color: #555;
				font-weight: normal;
				text-align: left;
			}
			.info.showing .content {
				display: block;
			}
			.treeUI-tree {
				/*display: inline-block;*/
				margin-right: 25px;
				margin-bottom: 15px;
			}
			/* The switch - the box around the slider
			Copy-Pasted from https://www.w3schools.com/howto/howto_css_switch.asp*/
			.switch {
				position: relative;
				display: inline-block;
				width: 40px;
				height: 24px;
			}

			/* Hide default HTML checkbox */
			.switch input {
				opacity: 0;
				width: 0;
				height: 0;
			}

			/* The slider */
			.slider {
				position: absolute;
				cursor: pointer;
				top: 0;
				left: 0;
				right: 0;
				bottom: 0;
				background-color: #ccc;
				-webkit-transition: .4s;
				transition: .4s;
			}

			.slider:before {
				position: absolute;
				content: "";
				height: 15px;
				width: 15px;
				left: 4px;
				bottom: 4px;
				background-color: white;
				-webkit-transition: .4s;
				transition: .4s;
			}

			input:checked + .slider {
				background-color: #6d86a3;
			}

			input:focus + .slider {
				box-shadow: 0 0 1px #2196F3;
			}

			input:checked + .slider:before {
				-webkit-transform: translateX(15px);
				-ms-transform: translateX(15px);
				transform: translateX(15px);
			}

			/* Rounded sliders */
			.slider.round {
				border-radius: 20px;
			}

			.slider.round:before {
				border-radius: 50%;
			}

			#doneMessage {
				display: none;
				color: #555;
				font-size: 13px;
				margin-left: 10px;
      }

			/* built in analysis dropdown */
			.dropdown {
				border: 0.1rem solid #6d86a3;
				font-size: 14px;
				height: 1.75rem;
			}

			.not-results{
				max-width: 40em;
			}

			#results-container{
				background-color: white;
				padding:2em; margin:2em;
			}

			#results-container:not(.show-tableau){
				display: none;
			}

		</style>

	</head>
	<body>
	<div style="padding-bottom:40px">
		<div class="header">
			<img src="images/logo.png" alt="SPOT">
			<span class="subtitle"><span style="display: inline-block; width:50%; font-size:larger;">Syntax Prosody in Optimality Theory </span><span style="display:inline-block; text-align:right;"><a href="https://spot.sites.ucsc.edu/">spot.sites.ucsc.edu/</a></span></span>
		</div>
		<div class="below-header" style="background-color: #d0d8e0;">

		<br/>
		<div style="margin-top: 10px"> Generate and evaluate prosodic and syntactic trees. View and download violation tableaux.
			<span class="info"><span class="content">
				<ul>
					<li>Click on the downward carets to see constraints and add constraints to your constraint set using the associated checkboxes.</li>
					<li>By default, XP and &phiv; are selected as the cateogories to assess violations over. Use the checkboxes below each constraint to change the desired category.</li>
					<li>SPOT is a JavaScript application. Make sure you have JavaScript enabled. We have tested SPOT in Firefox and Chrome, but not in Edge or Internet Explorer.</li>
				</ul>
			</span></span>
		</div>
		<div class="not-results">
			<div class="spotBlock">
				<h3>Built-in systems
				<span class="info"><span class="content" style="font-weight: normal;">To try an analysis from the syntax-prosody literature, select a built-in analysis from the menu, then scroll to the bottom and hit "Get results"</span></span></h3>
				<select class="dropdown" name="analysis" id="built-in-dropdown" onchange=built_in(this.value)>
					<option value="select">Select</option>
					<option value="irish">Irish Phrasing (Elfner 2012)</option>
					<option value="kinyambo">Kinyambo (Bellik & Kalivoda 2016)</option>
					<option value="ito&mester2017">Japanese (Ito & Mester 2017)</option>
					<optgroup label="ICPP2019 systems">
						<option value="japanese_rebracketing_1">Japanese: Match only</option>
						<option value="japanese_rebracketing_2">Japanese: Align only</option>
						<option value="japanese_rebracketing_3">Japanese: Match SP, Align SP</option>
						<option value="japanese_rebracketing_4">Japanese: Match PS, Align SP</option>
						<option value="japanese_rebracketing_5">Japanese: Match SP, Align PS</option>
						<option value="japanese_rebracketing_6">Japanese: Match PS, Align PS</option>
						<option value="japanese_BK_2019">Japanese/Basque accents</option>
						<option value="italian">Italian (Van Handel 2019)</option>
						<option value="chamorro">Chamorro (Bibbs 2019)</option>
					</optgroup>
				</select>

			</div>

			<form id="spotForm">
				<!--GEN OPTIONS-->
				<div class="spotBlock">
				<legend><h2>GEN options</h2></legend>

				<table class="spaceytable"><tbody>
					<tr>
						<td><input type="checkbox" name="genOptions" value="obeysNonrecursivity">No prosodic recursion.</td>
					</tr>
					<tr>
						<td><input type="checkbox" name="genOptions" value="obeysHeadedness">Enforce headedness.</td>
					</tr>
					<tr>
							<td><input type="checkbox" name="genOptions" id="exhaustivityBox" value="obeysExhaustivity">No level skipping.</td>
						</tr>
					<tr>
						<td id="exhaustivityDetailOption1" style="display: none; padding-left: 3em" ><input type="checkbox" name="exhaustivityCats" value="i" checked="checked">&iota;'s children are &ge;&phiv;s&nbsp;&nbsp;</td>
						<td id="exhaustivityDetailOption2" style="display: none"><input type="checkbox" name="exhaustivityCats" value="phi" checked="checked">&phiv;'s children are &ge;&omega;s&nbsp;&nbsp;</td>
					</tr>
					<tr>
						<td><input type="checkbox" name="genOptions" id="branchingBox" value="noUnary">Only generate branching constituents.</td>
					</tr>

					<tr>
						<td><input type="checkbox" name="genOptions" id="cliticMovementBox" value="cliticMovement">Allow clitics to move</td>
						<td class="info" width="300char"><div class="content">
								GEN will permute the first node in the syntactic tree with category 'clitic' through the sentence. Ex.: a b c-clitic -> a b c-clitic, a c-clitic b, c-clitic a b. Only use this if your sentences are short, or in conjunction with non-recursivity or the branching requirement.</div>
						</td>
					</tr>
				</tbody></table>
				<fieldset id="prosodicCategories">
					<legend><h2>Prosodic categories <span class="arrow"></span></h2></legend>
					<div class="constraint-row"><span>Root prosodic tree in</span>
						<div class="info">
							<span class="content">Specify the category of the root node for all the trees created by GEN.</span>
						</div>
					</div>
					<div class="category-row">
						<div class="category-selection-div"><input type="radio" name="genOptions-rootCategory" value="i" checked="checked">&iota;</div>
						<div class="category-selection-div"><input type="radio" name="genOptions-rootCategory" value="phi">&phiv;</div>
						<div class="category-selection-div"><input type="radio" name="genOptions-rootCategory" value="w">&omega;</div>
					</div>
				<div class="constraint-row"><span>Intermediate nodes are</span>
					<div class="info"><span class="content">Specify the category of the nodes below the root and above the terminals. This is the category where GEN will create recursion.</span></div>
				</div>
				<div class="category-row">
						<div class="category-selection-div"><input type="radio" name="genOptions-recursiveCategory" value="i">&iota;</div>
						<div class="category-selection-div"><input type="radio" name="genOptions-recursiveCategory" value="phi" checked="checked">&phiv;</div>
						<div class="category-selection-div"><input type="radio" name="genOptions-recursiveCategory" value="w">&omega;</div>
				</div>
				<div class="constraint-row"><span>Prosodic terminals are</span>
					<div class="info">
						<span class="content">Specify the category of the terminal nodes for the trees GEN will create. N.B. GEN will always map terminals marked with "-clitic" to syllables.</span></div>
					</div>
					<div class="category-row">
						<div class="category-selection-div"><input type="radio" name="genOptions-terminalCategory" value="phi">&phiv;</div>
						<div class="category-selection-div"><input type="radio" name="genOptions-terminalCategory" value="w" checked="checked">&omega;</div>
						<div class="category-selection-div"><input type="radio" name="genOptions-terminalCategory" value="Ft">Ft</div>
					</div>
				</fieldset>

				<fieldset id="treeDisplayOptions">
				<legend><h2>Tree display options <span class="arrow"></span></h2></legend>
				<div class="constraint-row"><input type="checkbox" name="genOptions" value="usesTones" id="annotatedWithTones">annotated with tones</div>
				<div class="category-row" style="display: none" id="tonesSelectionRow">
					<div class="category-selection-div" style="width: 180px"><input type="radio" name="toneOptions" value="addJapaneseTones" checked="checked">Japanese <div class="info" onclick="toneInfoBlock('japanese')"></div></div>
					<div class="category-selection-div" style="width: 180px"><input type="radio" name="toneOptions" value="addIrishTones_Elfner">Irish <div class="info" onclick="toneInfoBlock('irish')"></div></div>
					<br/>
					<div id="tonesInfoContent"></div>
				</div>

				<div class="constraint-row">Hide boundaries for nodes of category...</div>
				<div class="category-row">
					<div class="category-selection-div"><input type="checkbox" name="hideCategory" value="i">&iota;</div>
					<div class="category-selection-div"><input type="checkbox" name="hideCategory" value="phi">&phi;</div>
					<div class="category-selection-div"><input type="checkbox" name="hideCategory" value="w">&omega;</div>
				</div>
				</fieldset>
			</div>

			<!--INPUT-->
			<div class="spotBlock">
			<h2>Inputs
				<span class="info">
					<span class="content">
						To get prosodic candidate without building a syntactic tree, type the words that you want to be included in the output prosodic trees, separating them with spaces. Suffix a word with "-clitic" to map it to a syllable instead of &omega; in all prosodic trees. <b>N.B.</b> Input strings longer than 6 words may be very slow, and risk freezing your system.
					</span>
				</span>
			</h2>
			<p>String of terminals: <input type="text" name="inputToGen"> <button id="goButton" type="button">Build syntax</button><button class="orange-button" type="submit" style='margin-left: 5px'>Run GEN</button></p>

            <div id="treeUI" style="display: none">

              	<div id="treeUIinner" style="display: none">
              		<hr/>
              		<div>
              			<button class="nodeEditingButton" id="treeUImakeParent" type="button" disabled>Add Mother</button>
              			<button class="nodeEditingButton" id="treeUIdeleteNodes" type="button" disabled style="margin-right: 50px">Delete</button>
              			<button class="nodeEditingButton" id="treeUIclearSelection" type="button" disabled>Clear Selection</button>
              		</div>

              		<br/>
                	<div id="treeTableContainer"></div>
                	<i><small>
		            	<p>To add a node, select one or more adjacent sisters and click "Add Mother." To remove nodes, select them and click "Delete." </p>
						<p>All labels are editable. The small labels with grey backgrounds represent node categories, and must be "cp", "xp", or "x0" for a node to be visible to the syntax-prosody mapping constraints. Use "clitic" as the category for a node that should be mapped to a syllable instead of a &omega;. The larger labels with white backgrounds represent node ids, and can be any unique alphanumeric string.</p>
						<p>To create a new tree, click "Build syntax" again.</p>
		            </small></i>

                	<button id="htmlToJsonTreeButton" type="button">Done!<br><small></small>Add trees to analysis</small></button>

					</button>
									<div id="doneMessage">The trees in the analysis are up-to-date</div>


                	<p style="font-size: 15; vertical-align: middle"><label class="switch" style="margin-right: 10px;vertical-align: middle"><input type="checkbox" id="tree-code-box" value="show-tree-code"><span class="slider round"></span></label>Show code</p>
            	</div>

				<div style="display:none">
					<button id="danishJsonTreesButton" type="button">Danish Trees: generate s-tree code</button>
				</div>
				<div id="tree-code-area" style="display:none">
					<hr/>
					<p>To enter trees manually... <span class="info"><span class="content">To use a tree you previously made and saved, select a tree or trees from your JavaScript tree file (some pre-made trees are in the directory <i>main/trees</i>, and end with .js). Paste in the contents of JS file of your input syntactic tree(s) (from the opening brace to the closing brace, removing any comments and excluding the final semi-colon). Separate trees with a comma and surround the whole thing with square brackets ("[]") to make it an array. Note that if you're only using Markedness constraints, you can just keep the default value of an empty tree (like so: {}) as the syntactic input.</span></span></p>
					<textarea id="stree-textarea" class="stree-textarea" name="sTree" rows="15">{}</textarea>
				</div>
			</div>
		</div>

				<!--CONSTRAINTS-->
				<div class="spotBlock">
				<h2>Constraints</h2>
				<fieldset>

					<legend><h2>Syntax-prosody mapping <span class="arrow"></h2></legend>

					<h3>Align/Wrap</h3>

					<div class="constraint-selection-table">
						<div class="constraint-row">
							<span><input type="checkbox" name="constraints" value="alignLeft">Align-Left</span>
							<div class="info">
								<span class="content">Assign one violation for every node of category K in the syntactic tree whose left edge is not aligned with the left edge of a node of the prosodic category corresponding to K in the prosodic tree. SPOT function: alignLeft(). (Selkirk 1986, 1996)</span>
							</div>
						</div>

						<div class="category-row">
							<div class="category-selection-div"><input type="checkbox" name="category-alignLeft" value="cp">CP</div>
							<div class="category-selection-div"><input type="checkbox" name="category-alignLeft" value="xp" checked="checked">XP</div>
							<div class="category-selection-div"><input type="checkbox" name="category-alignLeft" value="x0">X<sup>0</sup></div>
						</div>
					</div>

					<div class="constraint-selection-table">
						<div class="constraint-row">
								<span><input type="checkbox" name="constraints" value="alignRight">Align-Right</span>
								<div class="info">
									<span class="content">Assign one violation for every node of category K in the syntactic tree whose right edge is not aligned with the left edge of a node of the prosodic category corresponding to K in the prosodic tree. SPOT function: alignRight(). (Selkirk 1986, 1996)</span>
								</div>
						</div>
						<div class="category-row">
							<div class="category-selection-div"><input type="checkbox" name="category-alignRight" value="cp">CP</div>
							<div class="category-selection-div"><input type="checkbox" name="category-alignRight" value="xp" checked="checked">XP</div>
							<div class="category-selection-div"><input type="checkbox" name="category-alignRight" value="x0">X<sup>0</sup></div>
						</div>
					</div>
					<div class="constraint-selection-table">
						<div class="constraint-row">
							<span><input type="checkbox" name="constraints" value="wrap">Wrap</span>
							<div class="info">
								<span class="content">Assign one violation for every node S of category K in the syntactic tree that does not have a corresponding node P in the syntactic tree, where P is of the category K corresponds to and P contains all the terminals dominated by S. SPOT function: wrap(). (Truckenbrodt 1995, 1999)</span>
							</div>
						</div>
						<div class="category-row">
								<div class="category-selection-div"><input type="checkbox" name="category-wrap" value="cp">CP</div>
								<div class="category-selection-div"><input type="checkbox" name="category-wrap" value="xp" checked="checked">XP</div>
								<div class="category-selection-div"><input type="checkbox" name="category-wrap" value="x0">X<sup>0</sup></div>
							</div>
						</div>

						<h3>Match Theory</h3>

						<div class="constraint-selection-table">
							<div class="constraint-row">
								<span><input type="checkbox" name="constraints" value="matchSP">Match(Syntax&rarr;Prosody)</span>
								<div class="info">
									<span class="content">Assign one violation for every node of category K in the syntactic tree such that there is no node of the corresponding prosodic category in the prosodic tree that dominates all and only the same terminal nodes. SPOT function: matchSP(). (Selkirk 2011, Elfner 2012)</span>
								</div>
							</div>
							<div class="category-row">
								<div class="category-selection-div"><input type="checkbox" name="category-matchSP" value="cp">CP</div>
								<div class="category-selection-div"><input type="checkbox" name="category-matchSP" value="xp" checked="checked">XP</div>
								<div class="category-selection-div"><input type="checkbox" name="category-matchSP" value="x0">X<sup>0</sup></div>
							</div>
							<div class="category-row">
								<div class="option-selection-div"><input type="checkbox" name="option-matchSP" value="requireLexical">lexical</div>
								<div class="info">
									<span class="content">Match only syntactic nodes that are not labeled as functional.</span>
								</div>
							</div>
							<div class="category-row">
								<div class="option-selection-div"><input type="checkbox" name="option-matchSP" value="requireOvertHead">overtly headed</div>
								<div class="info">
									<span class="content">Match only syntactic nodes that have a non-silent head.</span>
								</div>
							</div>
						</div>

						<div class="constraint-selection-table">
							<div class="constraint-row">
									<span><input type="checkbox" name="constraints" value="matchMaxSyntax">MatchMax(Syntax&rarr;Prosody)</span>
									<div class="info">
										<span class="content">Assign one violation for every maximal node of category K in the syntactic tree such that there is no maximal node of the category corresponding to K that dominates all and only the same terminal nodes in the prosodic tree. A node of category K is maximal iff it is not dominated by any other node of category K. SPOT function: matchMaxSP(). (Ito & Mester 2009, Ishihara 2014)</span>
									</div>
							</div>
							<div class="category-row">
								<div class="category-selection-div"><input type="checkbox" name="category-matchMaxSyntax" value="cp">CP</div>
								<div class="category-selection-div"><input type="checkbox" name="category-matchMaxSyntax" value="xp" checked="checked">XP</div>
								<div class="category-selection-div"><input type="checkbox" name="category-matchMaxSyntax" value="x0">X<sup>0</sup></div>
							</div>
							<div class="category-row">
								<div class="option-selection-div"><input type="checkbox" name="option-matchMaxSyntax" value="requireLexical">only lexical nodes</div>
								<div class="info">
									<span class="content">Match only maximal syntactic nodes that are not labeled as functional.</span>
								</div>
							</div>
							<div class="category-row">
								<div class="option-selection-div"><input type="checkbox" name="option-matchMaxSyntax" value="requireOvertHead">only overtly headed</div>
								<div class="info">
									<span class="content">Match only maximal syntactic nodes that have a non-silent head.</span>
								</div>
							</div>
						</div>

						<div class="constraint-selection-table">
							<div class="constraint-row">
								<span><input type="checkbox" name="constraints" value="matchNonMinSyntax">MatchNonMinimal(Syntax&rarr;Prosody)</span>
								<div class="info">
									<span class="content">Assign one violation for every non-minimal node of category K in the syntactic tree for which there is no node of the category corresponding to K in the prosodic tree that dominates all and only the same terminals. A node of category K is non-minimal iff it dominates at least one other node of category K. SPOT function: matchNonMinSyntax(). (Ito & Mester 2009, Kalivoda, Ito, & Mester 2019)</span>
								</div>
							</div>
							<div class="category-row">
									<div class="category-selection-div"><input type="checkbox" name="category-matchNonMinSyntax" value="cp">CP</div>
									<div class="category-selection-div"><input type="checkbox" name="category-matchNonMinSyntax" value="xp" checked="checked">XP</div>
									<div class="category-selection-div"><input type="checkbox" name="category-matchNonMinSyntax" value="x0">X<sup>0</sup></div>
							</div>
							<div class="category-row">
								<div class="option-selection-div"><input type="checkbox" name="option-matchNonMinSyntax" value="requireLexical">lexical</div>
								<div class="info">
									<span class="content">Match only non-minimal syntactic nodes that are not labeled as functional.</span>
								</div>
							</div>
							<div class="category-row">
								<div class="option-selection-div"><input type="checkbox" name="option-matchNonMinSyntax" value="requireOvertHead">overtly headed</div>
								<div class="info">
									<span class="content">Match only non-minimal syntactic nodes that have a non-silent head.</span>
								</div>
							</div>
						</div>

						<div class="constraint-selection-table">
							<div class="constraint-row">
								<span><input type="checkbox" name="constraints" value="matchCustom">Custom Match(Syntax&rarr;Prosody)</span>
								<div class="info">
									<span class="content">Create your own custom Match constraint.</span>
								</div>
							</div>
							<div class="category-row">
								<div class="category-selection-div"><input type="checkbox" name="category-matchCustom" value="cp">CP</div>
								<div class="category-selection-div"><input type="checkbox" name="category-matchCustom" value="xp" checked="checked">XP</div>
								<div class="category-selection-div"><input type="checkbox" name="category-matchCustom" value="x0">X<sup>0</sup></div>
							</div>
							<div class="category-row">
								<div class="custom-text">
									<p>Enforce Match only for syntactic nodes that are...</p>
								</div>
								<div class="option-selection-div custom-option-div"><input type="checkbox" name="option-matchCustom" value="requireLexical">lexical</div>
								<div class="info">
									<span class="content custom-option-div">Match only syntactic nodes that are not labeled as functional.</span>
								</div>
							</div>
							<div class="category-row">
								<div class="option-selection-div custom-option-div"><input type="checkbox" name="option-matchCustom" value="requireOvertHead">overtly headed</div>
								<div class="info">
									<span class="content custom-option-div">Match only syntactic nodes that have a non-silent head.</span>
								</div>
							</div>
							<div class="category-row">
								<div class="option-selection-div custom-option-div">
									<select name="option-matchCustom">
										<option value="any">Any</option>
										<option value="maxSyntax">+</option>
										<option value="nonMaxSyntax">-</option>
									</select> maximal
								</div>
								<div class="info">
									<span class="content custom-option-div">A node is maximal if it does not dominate any nodes of its own category.</span>
								</div>
							</div>
							<div class="category-row">
								<div class="option-selection-div custom-option-div">
									<select name="option-matchCustom">
										<option value="any">Any</option>
										<option value="minSyntax">+</option>
										<option value="nonMinSyntax">-</option>
									</select> minimal
								</div>
								<div class="info">
									<span class="content custom-option-div">A node is minimal if it is not dominated by any nodes of its own category.</span>
								</div>
							</div>
							<div class="category-row">
								<div class="custom-text">
									<p>Prosodic categories must be...</p>
								</div>
								<div class="option-selection-div custom-option-div">
									<select name="option-matchCustom">
										<option value="any">Any</option>
										<option value="maxProsody">+</option>
										<option value="nonMaxProsody">-</option>
									</select> maximal
								</div>
								<div class="info">
									<span class="content custom-option-div">A node is maximal if it does not dominate any nodes of its own category.</span>
								</div>
							</div>
							<div class="category-row">
								<div class="option-selection-div custom-option-div">
									<select name="option-matchCustom">
										<option value="any">Any</option>
										<option value="minProsody">+</option>
										<option value="nonMinProsody">-</option>
									</select> minimal
								</div>
								<div class="info">
									<span class="content custom-option-div">A node is minimal if it is not dominated by any nodes of its own category.</span>
								</div>
							</div>
						</div>

						<div class="constraint-selection-table">
							<div class="constraint-row">
								<span><input type="checkbox" name="constraints" value="matchPS">Match (Prosody&rarr;Syntax)</span>
								<div class="info">
									<span class="content">Assign one violation for every node of category K in the prosodic tree such that there is no node of the corresponding syntactic category in the syntactic tree that dominates all and only the same terminal nodes. SPOT function: matchPS(). (Selkirk 2011)</span>
								</div>
							</div>
							<div class="category-row">
								<div class="category-selection-div"><input type="checkbox" name="category-matchPS" value="i">&iota;</div>
								<div class="category-selection-div"><input type="checkbox" name="category-matchPS" value="phi" checked="checked">&phiv;</div>
								<div class="category-selection-div"><input type="checkbox" name="category-matchPS" value="w">&omega;</div>
							</div>
						</div>

			</fieldset>

				<br/>

				<fieldset>

					<legend><h2>Binarity <span class="arrow"></h2></legend>

					<h3>...counting branches</h3>

					<div class="constraint-selection-table">
						<div class="constraint-row">
							<span><input type="checkbox" name="constraints" value="binMinBranches">BinMin(branches)</span>
							<div class="info">
								<span class="content">Assign one violation for every node of category K in the prosodic tree that has less than two children. SPOT function: binMinBranches(). (Elfner 2012).</span>
							</div>
						</div>
							<div class="category-row">
								<div class="category-selection-div"><input type="checkbox" name="category-binMinBranches" value="i">&iota;</div>
								<div class="category-selection-div"><input type="checkbox" name="category-binMinBranches" value="phi" checked="checked">&phiv;</div>
								<div class="category-selection-div"><input type="checkbox" name="category-binMinBranches" value="w">&omega;</div>
							</div>
					</div>

					<div class="constraint-selection-table">
						<div class="constraint-row">
							<span><input type="checkbox" name="constraints" value="binMaxBranches">BinMax(branches) - <i>categorical</i></span>
							<div class="info">
								<span class="content">Assign one violation for every node of category K in the prosodic tree that has more than two children. SPOT function: binMaxBranches(). For branch-counting concept, see, e.g., Elfner 2012, Selkirk & Lee 2017 (SPOT1 Workshop handout). For contrast with leaf-counting binarity, see Bellik & Kalivoda 2018 (Poster at the Annual Meeting on Phonology)</span>
							</div>
						</div>
							<div class="category-row">
								<div class="category-selection-div"><input type="checkbox" name="category-binMaxBranches" value="i">&iota;</div>
								<div class="category-selection-div"><input type="checkbox" name="category-binMaxBranches" value="phi" checked="checked">&phiv;</div>
								<div class="category-selection-div"><input type="checkbox" name="category-binMaxBranches" value="w">&omega;</div>
							</div>
					</div>

					<div class="constraint-selection-table">
						<div class="constraint-row">
							<span><input type="checkbox" name="constraints" value="binMaxBranchesGradient">BinMax(branches) - <i>gradient</i></span>
							<div class="info">
								<span class="content">For every node P of category K in the prosodic tree, assign one violation for every child of P that is not initial or pen-initial in P. SPOT function: binMaxBranchesGradient()</span>
							</div>
						</div>
							<div class="category-row">
								<div class="category-selection-div"><input type="checkbox" name="category-binMaxBranchesGradient" value="i">&iota;</div>
								<div class="category-selection-div"><input type="checkbox" name="category-binMaxBranchesGradient" value="phi" checked="checked">&phiv;</div>
								<div class="category-selection-div"><input type="checkbox" name="category-binMaxBranchesGradient" value="w">&omega;</div>
							</div>
					</div>

					<h3>...counting leaves</h3>


					<div class="constraint-selection-table">
						<div class="constraint-row">
							<span><input type="checkbox" name="constraints" value="binMinLeaves">BinMin(leaves)</span>
							<div class="info">
								<span class="content">Assign one violation for every node P of the prosodic category K in the prosodic tree such that P dominates less than two nodes of the prosodic category immediately below K on the prosodic hierarchy. SPOT function: binMinLeaves. SPOT function: binMaxLeaves(). (Selkirk 2000)</span>
							</div>
						</div>
							<div class="category-row">
								<div class="category-selection-div"><input type="checkbox" name="category-binMin" value="i">&iota;</div>
								<div class="category-selection-div"><input type="checkbox" name="category-binMinLeaves" value="phi" checked="checked">&phiv;</div>
								<div class="category-selection-div"><input type="checkbox" name="category-binMinLeaves" value="w">&omega;</div>
							</div>
					</div>

					<div class="constraint-selection-table">
						<div class="constraint-row">
							<span><input type="checkbox" name="constraints" value="binMaxLeaves">BinMax(leaves) - <i>categorical</i></span>
							<div class="info">
								<span class="content">Assign one violation for every node of category K in the prosodic tree that dominates more than two nodes of the category immediately below K on the prosodic hierarchy. SPOT function: binMaxLeaves(). Assign a violation for every node of category P in the prosodic tree that contains more than two nodes of category P-1 at any level. For example, the prosodic tree ((a b)(c d)), where a, b, c, d are all prosodic words, would incur one violation for the top-level phi, which contains four prosodic words, even though it has only two immediate children. Concept: see, Selkirk 2000, Sandalo & Truckenbrodt 2002</span>
							</div>
						</div>
							<div class="category-row">
								<div class="category-selection-div"><input type="checkbox" name="category-binMaxLeaves" value="i">&iota;</div>
								<div class="category-selection-div"><input type="checkbox" name="category-binMaxLeaves" value="phi" checked="checked">&phiv;</div>
								<div class="category-selection-div"><input type="checkbox" name="category-binMaxLeaves" value="w">&omega;</div>
							</div>
					</div>

					<div class="constraint-selection-table">
						<div class="constraint-row">
							<span><input type="checkbox" name="constraints" value="binMaxLeavesGradient">BinMax(leaves) - <i>gradient</i></span>
							<div class="info">
								<span class="content">For every node P of category K in the prosodic tree, assign one violation for every node dominated by P that is of the category immediately below K on the prosodic hierarchy and that is not initial or pen-initial in P. SPOT function: binMaxLeavesGradient().</span>
							</div>
						</div>
							<div class="category-row">
								<div class="category-selection-div"><input type="checkbox" name="category-binMaxLeavesGradient" value="i">&iota;</div>
								<div class="category-selection-div"><input type="checkbox" name="category-binMaxLeavesGradient" value="phi" checked="checked">&phiv;</div>
								<div class="category-selection-div"><input type="checkbox" name="category-binMaxLeavesGradient" value="w">&omega;</div>
							</div>
					</div>

				</fieldset>

				<br/>

				<fieldset>

					<legend><h2>Sisterhood and ordering <span class="arrow"></h2></legend>

					<div class="constraint-selection-table">
						<div class="constraint-row">
								<span><input type="checkbox" name="constraints" value="noShift">NoShift</span>
								<div class="info"><span class="content">Assign a violation if the terminals in the prosodic tree do not maintain the same precedence relations as those in the syntactic tree. (Bennett et al. 2016)</span></div>
						</div>
					</div>

					<div class="constraint-selection-table">
						<div class="constraint-row">
							<span><input type="checkbox" name="constraints" value="alignLeftMorpheme">AlignLeft (Lexical item)</span>
							<div class="info"><span class="content">For the specified morpheme(s), assign a violation for every terminal that intervenes between the left edge of the tree and the lexical item. Separate lexical items with spaces. See: McCarthy & Prince 1993, "Generalized Alignment"</span></div>
						</div>
						<div class="category-row">
							<div class="category-selection-div"><input type="text" name="category-alignLeftMorpheme" checked="true" placeholder="Lexical item(s)"></div>
						</div>
					</div>

					<div class="constraint-selection-table">
						<div class="constraint-row">
							<span><input type="checkbox" name="constraints" value="balancedSistersAdj">BalancedSisters (Uniformity)</span>
							<div class="info"><span class="content">Assign one violation for every pair of adjacent sisters with a parent of category K that do not have the same number of children. (For concept of Uniformity, see Ghini 1993; for OT constraint, see Bellik 2019)</span></div>
						</div>
						<div class="category-row">
							<div class="category-selection-div"><input type="checkbox" value=i name="category-balancedSistersAdj">&iota;</div>
							<div class="category-selection-div"><input type="checkbox" value=phi name="category-balancedSistersAdj">&phi;</div>
							<div class="category-selection-div"><input type="checkbox" value=w name="category-balancedSistersAdj">&omega;</div>
						</div>
					</div>

					<h3>EqualSisters</h3>

						<div class="constraint-selection-table">
							<div class="constraint-row">
								<span><input type="checkbox" name="constraints" value="equalSistersAdj">EqualSisters (adjacent)</span>
								<div class="info">
									<span class="content">Assign one violation for every pair of adjacent sister nodes that are not of the same prosodic category. SPOT function: equalSistersAdj(). (c.f. Myrberg 2010). Concept: Myrberg 2010. Specific formulation: SPOT. See Bellik & Kalivoda 2017 (SPOT1 Workshop slides) for discussion of implications.</span>
								</div>
							</div>
						</div>

						<div class="constraint-selection-table">
							<div class="constraint-row">
								<span><input type="checkbox" name="constraints" value="equalSistersPairwise">EqualSisters (pairwise)</span>
								<div class="info">
									<span class="content">Assign one violation for every (unordered) pair of sisters nodes that are not of the same prosodic category. SPOT function: equalSistersPairwise(). (c.f. Myrberg 2010). Concept: Myrberg 2010. Specific formulation: SPOT. See Bellik & Kalivoda 2017 (SPOT1 Workshop slides) for discussion of implications.</span>
								</div>
							</div>
						</div>

						<div class="constraint-selection-table">
							<div class="constraint-row">
								<span><input type="checkbox" name="constraints" value="equalSistersFirstPrivilege">EqualSisters (first privilege)</span>
								<div class="info">
									<span class="content">For each set of sisters, assign one violation for every child that has a different prosodic category from the first (leftmost) sister in the set. SPOT function: equalSistersFirstPrivilege(). (c.f. Myrberg 2010). Concept: Myrberg 2010. Specific formulation: SPOT. See Bellik & Kalivoda 2017 (SPOT1 Workshop slides) for discussion of implications.</span>
								</div>
							</div>
						</div>

						<div class="constraint-selection-table">
							<div class="constraint-row">
								<span><input type="checkbox" name="constraints" value="equalSisters2">EqualSisters2</span>
								<div class="info">
									<span class="content">For each set of sisters, assign one violation for every child whose prosodic category is lower than that of a non-minimal sister. E.g., assign a violation for &omega; that is adjacent to a non-minimal &phi;, but don't assign a violation for &omega; that is adjecent to a minimal &phi;. SPOT function: equalSisters2. Ito & Mester 2017.</span>
								</div>
							</div>
						</div>

					<h3>StrongStart</h3>

					<div class="constraint-selection-table">
						<div class="constraint-row">
							<span><input type="checkbox" name="constraints" value="strongStart_Elfner">StrongStart</span>
							<div class="info">
								<span class="content">Assign one violation for every node in the syntactic tree whose leftmost daughter is lower in the prosodic hierarchy than its sister constituent immediately to its right. (Elfner's StrongStart) SPOT function: strongStart_Elfner(). (Selkirk 2011, Elfner 2012.)</span>
							</div>
						</div>
						<div class="category-row">
							<div class="category-selection-div"><input type="checkbox" name="category-strongStart_Elfner" value="i">&iota;</div>
							<div class="category-selection-div"><input type="checkbox" name="category-strongStart_Elfner" value="phi">&phiv;</div>
							<div class="category-selection-div"><input type="checkbox" name="category-strongStart_Elfner" value="w" checked="checked">&omega;</div>
							<div class="category-selection-div"><input type="checkbox" name="category-strongStart_Elfner" value="syll">&sigma;</div>
						</div>
					</div>

				</fieldset>

				<br/>

				<fieldset>

					<legend><h2>Layering <span class="arrow"></h2></legend>


					<div class="constraint-selection-table">
						<div class="constraint-row">
							<span><input type="checkbox" name="constraints" value="exhaust1">Exhaustivity</span>
							<div class="info">
								<span class="content">Assign one violation for every parent-child pair such that the child’s prosodic category is more than one level lower than the parent’s prosodic category. E.g., phi with a syllable child, i with a w child. SPOT function: exhaust1(). For Exhaustivity as a violable constraint, see Selkirk 1995 “The prosodic structure of function words”</span>
							</div>
						</div>
					</div>

					<div class="constraint-selection-table">
						<div class="constraint-row">
							<span><input type="checkbox" name="constraints" value="nonRecChild">Non-recursivity, assessed by dominated node (nonRecChild)</span>
							<div class="info">
								<span class="content">Assign one violation for every node of category K immediately dominated by another node of category K. SPOT function: nonRecChild(). For Non-Recursivity as a violable constraint, see Selkirk 1995, Zec 2005. For this specific implementation & implications, see Bellik & Kalivoda 2017 (SPOT1 Workshop slides)</span>
							</div>
						</div>
							<div class="category-row">
								<div class="category-selection-div"><input type="checkbox" name="category-nonRecChild" value="i">&iota;</div>
								<div class="category-selection-div"><input type="checkbox" name="category-nonRecChild" value="phi" checked="checked">&phiv;</div>
								<div class="category-selection-div"><input type="checkbox" name="category-nonRecChild" value="w">&omega;</div>
							</div>
					</div>

					<div class="constraint-selection-table">
						<div class="constraint-row">
							<span><input type="checkbox" name="constraints" value="nonRecParent">Non-recursivity, assessed by dominating node (nonRecParent)</span>
							<div class="info">
								<span class="content">Assign one violation for every node of category K that immediately dominates a node of category K in the prosodic tree. SPOT function: nonRecParent(). For Non-Recursivity as a violable constraint, see Selkirk 1995, Zec 2005. For this specific implementation & implications, see Bellik & Kalivoda 2017 (SPOT1 Workshop slides)</span>
							</div>
						</div>
							<div class="category-row">
								<div class="category-selection-div"><input type="checkbox" name="category-nonRecParent" value="i">&iota;</div>
								<div class="category-selection-div"><input type="checkbox" name="category-nonRecParent" value="phi" checked="checked">&phiv;</div>
								<div class="category-selection-div"><input type="checkbox" name="category-nonRecParent" value="w">&omega;</div>
							</div>
					</div>

					<div class="constraint-selection-table">
						<div class="constraint-row">
							<span><input type="checkbox" name="constraints" value="nonRecTruckenbrodt">Non-recursivity, assessed by non-overlapping leaves (nonRecTruckenbrodt)</span>
							<div class="info">
								<span class="content">For every node X of category K dominated by another node Y of category K in the prosodic tree, assign one violation for every leaf dominated by Y that is not also dominated by X. SPOT function: nonRecTruckenbrodt(). (Truckenbrodt 1999)</span>
							</div>
						</div>
							<div class="category-row">
								<div class="category-selection-div"><input type="checkbox" name="category-nonRecTruckenbrodt" value="i">&iota;</div>
								<div class="category-selection-div"><input type="checkbox" name="category-nonRecTruckenbrodt" value="phi" checked="checked">&phiv;</div>
								<div class="category-selection-div"><input type="checkbox" name="category-nonRecTruckenbrodt" value="w">&omega;</div>
							</div>
					</div>

					<div class="constraint-selection-table">
						<div class="constraint-row">
							<span><input type="checkbox" name=constraints value="nonRecPairs">Non-recursivity, pairwise</span>
							<div class="info">
								<span class="content">Assign one violation for every pair of nodes X and Y in the prosodic tree such that X and Y are both of category K and X dominates Y. SPOT function: nonRecPairs(). For Non-Recursivity as a violable constraint, see Selkirk 1995, Zec 2005. For this specific implementation & implications, see Bellik & Kalivoda 2017 (SPOT1 Workshop slides)</span>
							</div>
						</div>
							<div class="category-row">
								<div class="category-selection-div"><input type="checkbox" name="category-nonRecPairs" value="i">&iota;</div>
								<div class="category-selection-div"><input type="checkbox" name="category-nonRecPairs" value="phi" checked="checked">&phiv;</div>
								<div class="category-selection-div"><input type="checkbox" name="category-nonRecPairs" value="w">&omega;</div>
							</div>
					</div>

				</fieldset>
				<br/>

				<fieldset>
					<legend><h2>Constraints on accentedness <span class="arrow"></h2></legend>
					<span class="info"><span class="content">Constraints proposed for analysis of lexical accent systems (Japanese, Basque). Accents must be indicated either by using 'a'/'u' or 'A'/'U' for the ids of words, or by adding accent attributes in the syntactic tree.</span></span>
					<div class="constraint-selection-table">
						<div class="constraint-row">
							<span><input type="checkbox" name="constraints" value="accentAsHead">AccentAsHead</span>
							<div class="info">
								<span class="content">accend as head info.</span>
							</div>
						</div>
					</div>
					<div class="constraint-selection-table">
						<div class="constraint-row">
							<span><input type="checkbox" name="constraints" value="noLapseL">NoLapse-L</span>
							<div class="info">
								<span class="content">NoLapse-L info.</span>
							</div>
						</div>
					</div>
				</fieldset>
			</div>

				<div align="center" id="save-load-section">
					<button id="clearAllButton" type="button" style="margin:5px">Clear All
					</button>
					<button onclick='saveAnalysis(record_analysis(), (window.prompt("Save analysis as...\n(the analysis will be saved as a file with the extension .SPOT)", "myAnalysis") || "myAnalysis"))' type="button" style="margin:5px">Save
					</button>
					<button onclick="document.getElementById('chooseFile').style='display: block'; document.getElementById('save/load-dialog').innerHTML = ''" type="button" style="margin:5px">Load
					</button>
					<br/>
					<div id="chooseFile" style="display: none">
						<div style="font-size: 13px; color: #555" id="chooseFilePrompt">
							Upload an analysis that you previously downloaded from SPOT:
						</div>
						<br/>
						<input type="file" accept=".SPOT" id="fileUpload" onchange="loadAnalysis(this.files[this.files.length-1])">
					</div>
					<br/>
					<p id="save/load-dialog" style="font-size: 13px; color: #555">
					</p>
					<br/>
					<button class="orange-button submit-button" type="submit">Get results</button>

					<h2>Scroll down for results!
						<span class="info">
							<span class="content">
								Clicking "Get results" will initiate a download of a tab-separated version of the resulting tableau.
								The tab-separated version of the tableau will also appear in a text-area, from which it can be copy-pasted. (Use Control-A to select it if it's not already selected.)
								An html version of the tableau will also display below.
							</span>
						</span>
					</h2>
				</div>
			</form>
		</div><!-- end of under not-results-->
			<pre id="results-container"></pre>

		</div>
	</div>

	</body>
</html>
