<html><head> 
    <title>Add Minimal Phi Head Testing</title>

	<link rel="stylesheet" type="text/css" href="../spot.css">

    <!--If running tests that do not have to do with the interface, run jsbuild.sh or jsbuild.bat
        in root directory of the project. If running interface testing, run testbuild.sh
        or testBuild.bat-->
    <script src="../build/spot.js"></script>

    <!--Mocha setup stuff (1/2)-->
    <meta charset="UTF-8">
    <script src="../lib/test/mocha.min.js"></script>
    <script src="../lib/test/chai.min.js"></script>
    <link rel="stylesheet" type="text/css" href="../lib/test/mocha.css">
    <!--mocha setup stuff to be continued in document body-->
    
</head>
<body style="padding-left: 5%; padding-right: 5%; padding-top: 20px">

    <h2>SPOT Automated Testing</h2>

    <!--Mocha stuff (2/2)-->
    <script>
        mocha.setup("bdd"); //brings "describe", "it", etc. into global namespace
        //mocha.checkLeaks();
        var assert = chai.assert; //no one wants to type out "chai.assert" every time
    </script>
    <div id="mocha"></div>
    <!--Mocha is set up now, you just need to write and run tests-->
    <script>
        describe("copyNode", function() {
            let testNode;
            beforeEach(function() {
                testNode = {
                    id: "root",
                    cat: "phi",
                    children: [
                        {id: "kid1", cat: "w",},
                        {id: "kid2", cat: "w",},
                        {
                            id: "intermediate",
                            cat: "phi",
                            children: [
                                {id: "kid3", cat: "w",},
                                {id: "kid4", cat: "w",},
                                {id: "kid5", cat: "w",},
                            ],
                        },
                    ],
                };
            });

            it("notEqual", function () {
                assert.notEqual(testNode, copyNode(testNode));
            });

            it("but deepEqual", function () {
                assert.deepEqual(testNode, copyNode(testNode));
            });

            it("and don't follow eachother", function () {
                let nodeCopy = copyNode(testNode);
                testNode.head = true;
                assert.isUndefined(nodeCopy.head);

                nodeCopy.cat = 'i';
                assert.equal(testNode.cat, 'phi');
            });

            it("Recursive copy", function () {
                assert.notEqual(testNode.children[0], copyNode(testNode).children[0]);
            });
        });

        describe("isHeaded", function() {
            let testNode;

            beforeEach(function() {
                testNode = {
                    id: "root",
                    cat: "phi",
                    children: [
                        {id: "kid1", cat: "w",},
                        {id: "kid2", cat: "w",},
                        {id: "kid3", cat: "w",},
                        {id: "kid4", cat: "w",},
                        {id: "kid5", cat: "w",},
                    ],
                };
            });

            it("Identifies left-headed node", function () {
                testNode.children[0].head = true;
                assert.isTrue(isHeaded(testNode));
            });

            it("Identifies right-headed node", function () {
                testNode.children[4].head = true;
                assert.isTrue(isHeaded(testNode));
            });
            it("Identifies middle-headed node", function () {
                testNode.children[2].head = true;
                assert.isTrue(isHeaded(testNode));
            });

            it("Identifies unheaded node", function () {
                assert.isFalse(isHeaded(testNode));
            });
        });

        describe("addLeftHead", function() {
            let testNode;

            beforeEach(function() {
                testNode = addLeftHead({
                    id: "root",
                    cat: "phi",
                    children: [
                        {id: "kid1", cat: "w",},
                        {id: "kid2", cat: "w",},
                        {id: "kid3", cat: "w",},
                        {id: "kid4", cat: "w",},
                        {id: "kid5", cat: "w",},
                    ],
                });
            });

            it("Result is Headed", function () {
                assert.isTrue(isHeaded(testNode));
            });
            
            it("Left node is head", function () {
                assert.isTrue(testNode.children[0].head);
            });

            it("Non-left nodes are not headed", function () {
                for(let child of testNode.children.slice(1)) {
                    assert.isUndefined(child.head);
                }
            });

            it("Does not break if given terminal", function () {
                assert.isOk(addLeftHead(testNode.children[4]));
            });

            it("Does not bread if given an already left-headed node", function () {
                assert.isOk(addLeftHead(testNode));
            });
        });

        describe("addRightHead", function() {
            let testNode;

            beforeEach(function() {
                testNode = addRightHead({
                    id: "root",
                    cat: "phi",
                    children: [
                        {id: "kid1", cat: "w",},
                        {id: "kid2", cat: "w",},
                        {id: "kid3", cat: "w",},
                        {id: "kid4", cat: "w",},
                        {id: "kid5", cat: "w",},
                    ],
                });
            });

            it("Result is Headed", function () {
                assert.isTrue(isHeaded(testNode));
            });
            
            it("Right node is head", function () {
                assert.isTrue(testNode.children[4].head);
            });

            it("Non-right nodes are not headed", function () {
                for(let child of testNode.children.slice(0, 4)) {
                    assert.isUndefined(child.head);
                }
            });

            it("Does not break if given terminal", function () {
                assert.isOk(addRightHead(testNode.children[0]));
            });

            it("Does not break if given an already right-headed node", function () {
                assert.isOk(addRightHead(testNode));
            });
        });

        describe("getMinimalNodes", function() {
            it("{(a) b}", function () {
                let testList = getMinimalNodes({id: 'root', cat: 'i', children: [
                    {
                        id: 'intermediate',
                        cat: 'phi',
                        children: [{id: "a", cat: "w",}],
                    },
                    {id: "b", cat: "w",},
                ]});
                assert.lengthOf(testList, 1);
                assert.equal(testList[0].children[0].id, 'a');
            });

            it("(a (b (c)))", function () {
                let testList = getMinimalNodes({
                    id: 'root',
                    cat: 'phi',
                    children: [
                        {id: 'a', cat: 'w'},
                        {
                            id: 'intermediate',
                            cat: 'phi',
                            children: [
                                {id: 'b', cat: 'w'},
                                {
                                    id: 'minimal',
                                    cat: 'phi',
                                    children: [
                                        {id: 'c', cat: 'w'}
                                    ]
                                }
                            ]
                        }
                    ]
                });
                assert.lengthOf(testList, 1);
                assert.equal(testList[0].children[0].id, 'c')
            });
        });

        describe("addHeadsTo", function() {
            let testTrees = {
                '(a)': {id: 'root', cat: 'phi', children: [
                        {id: "a", cat: "w",},
                    ],
                },
                '(a b c)': {id: 'root', cat: 'phi', children: [
                        {id: "a", cat: "w",},
                        {id: "b", cat: "w",},
                        {id: "c", cat: "w",},
                    ],
                },
                '{(a) b}': {id: 'root', cat: 'i', children: [
                        {
                            id: 'intermediate',
                            cat: 'phi',
                            children: [{id: "a", cat: "w",}],
                        },
                        {id: "b", cat: "w",},
                    ],
                },
            };

            it("Correct length for (a)", function () {
                assert.lengthOf(addHeadsTo(testTrees['(a)']), 1);
            });

            it("All headed for (a)", function () {
                for(let tree of addHeadsTo(testTrees['(a)'])) {
                    assert.isTrue(isHeaded(tree));
                };
            });

            it("Original (a) unchanged", function () {
                node = testTrees['(a)'];
                assert.isUndefined(node.head);
            });

            it("Correct length of (a b c)", function () {
                assert.lengthOf(addHeadsTo(testTrees['(a b c)']), 2);
            });

            it("All headed for (a b c)", function () {
                for(let tree of addHeadsTo(testTrees['(a b c)'])) {
                    assert.isTrue(isHeaded(tree));
                };
            });

            it("All one-headed for (a b c)", function () {
                let tree1, tree2;
                for(let tree of addHeadsTo(testTrees['(a b c)'])) {
                    let numOfHeads = 0;
                    for(let terminal of tree.children) {
                        numOfHeads += terminal.head ? 1 : 0;
                    }
                    assert.equal(numOfHeads, 1);
                }
            });

            it("All unique for (a b c)", function () {
                let tree1, tree2;
                [tree1, tree2] = addHeadsTo(testTrees['(a b c)']);
                assert.notDeepEqual(tree1, tree2);
            });

            it("Doesn't break when non-exhaustive", function () {
                assert.lengthOf(addHeadsTo(testTrees['{(a) b}']), 1);
            });

            it("Works for ((a) b (c))", function () {
                
            });
        });

        describe("addMinimalNodeHeads", function() {
            let testTrees, testGENoutput, expectedOutput;
            beforeEach(function() {
                testTrees = [
                    {id: 'root', cat: 'phi', children: [
                        {id: 'supra-a', cat: 'phi', children: [
                            {cat: 'w', id: 'a'}
                        ]},
                        {cat: 'w', id: 'b'},
                        {id: 'supra-c', cat: 'phi', children: [
                            {cat: 'w', 'id': 'c'}
                        ]}
                    ]},
                    {id: 'root', cat: 'i', children: [
                        {id: 'supra-a', cat: 'phi', children: [
                            {cat: 'w', id: 'a'}
                        ]},
                        {cat: 'w', id: 'b'},
                        {id: 'supra-c', cat: 'phi', children: [
                            {cat: 'w', 'id': 'c'}
                        ]}
                    ]},
                ]
                testGENoutput = [[{}, testTrees[0]], [{}, testTrees[1]]]
                expectedOutput = [
                    {id: 'root', cat: 'phi', children: [
                        {id: 'supra-a', cat: 'phi', children: [
                            {cat: 'w', id: 'a', head: true}
                        ]},
                        {cat: 'w', id: 'b'},
                        {id: 'supra-c', cat: 'phi', children: [
                            {cat: 'w', 'id': 'c', head: true}
                        ]}
                    ]},
                    {id: 'root', cat: 'i', children: [
                        {id: 'supra-a', cat: 'phi', children: [
                            {cat: 'w', id: 'a', head: true}
                        ]},
                        {cat: 'w', id: 'b'},
                        {id: 'supra-c', cat: 'phi', children: [
                            {cat: 'w', 'id': 'c', head: true}
                        ]}
                    ]},
                ]
            });
            it("works for gen output", function () {
                assert.deepEqual(expectedOutput, addMinimalNodeHeads(testGENoutput));
            });

            it("works for list of trees", function () {
                assert.deepEqual(expectedOutput, addMinimalNodeHeads(testTrees));
            });
        });

        mocha.run();
    </script>

</body></html>
