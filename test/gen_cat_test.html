<html>
<head>
	<title>SPOT investigation: autogenerating inputs</title>

	<link rel="stylesheet" type="text/css" href="../spot.css">

	<script src="../lib/jszip.min.js"></script>
    <script src="../trees/abstractMatchTrees.js"></script>
	

	<!-- to keep spot.js in sync with the codebase make sure to run jsbuild.sh after making any changes to javascript files in the main directory or in the constraints sub-directory
	(open a terminal, cd into the main directory, type ./jsbuild.sh and hit enter) -->
	<script src="../build/spot.js"></script>	

				
</head>

<body style="padding-left: 5%; padding-right: 5%; padding-top: 20px">
	<h2>GENerating inputs</h2>
	<pre id="results-container"></pre>

<script>
	// ---- Variables that need to be customized ----
	
	/*Constraint sets.*/
	var MatchSPMatchPS = ['binMaxBranches-phi', 'binMinBranches-phi', 'matchSP-xp'];
	
	/*A list of names for constraint sets.*/
	var conNames = ['MatchSPMatchPS'];
	
	//Candidate sets are generated with the options below.
    	
	//Errors expected from GEN since phi isn't in the specified PH.
	var i_phi_w = {rootCategory:'i', recursiveCategory:'phi', terminalCategory: 'w', ph:PH_MAJMIN};

	//Error expected from checkProsodicHierarchy, called by GEN, since pCat doesn't match categoryPairings.
	var phi_phi_w = {rootCategory:'phi', recursiveCategory:'phi', terminalCategory: 'w', ph:{pCat: PH_MAJMIN.pCat, categoryPairings: PH_PHI.categoryPairings}};

	//No errors expected?
	var phi_w_w = {rootCategory:'phi', recursiveCategory:'w', terminalCategory: 'w'};

	//Errors expected since 
	var majorPhrase = {rootCategory: 'i', terminalCategory: 'w', recursiveCategory: 'MaP',ph:PH_PHI};
	var minorPhrase = {obeysNonRecursivity: true, rootCategory: 'i', terminalCategory: 'w', recursiveCategory: 'MiP', ph:PH_MAJMIN};
		 
	var myCategoryBrackets = {
		"i": "{}",
		"cp": "{}",
		"xp": "[]",
		"phi": "()",
		"x0": ["[x0 ","]"],
		"w": ["[", "]"],
		"clitic": ["",""],
		"syll": ["",""],
		"Ft": ["", ""],
		"u": ["{u ", "}"]
	};
	var output_gen_opt_list = [i_phi_w, phi_phi_w, phi_w_w, majorPhrase, minorPhrase];

	
	// ---- Functions that don't necessarily need to be customized ----
	
    function makeTableauCsvs(consName) {
        var csvSegs = [];	//List to accumulate tableaux in
		
        //For each syntactic tree in sTreeList, make a tableau using the current constraint set
        for(var j=0; j<output_gen_opt_list.length; j++){
			
			//Make the candidate set using the GEN function (defined in candidategenerator.js)
            //Leave the 2nd argument as an empty string to scrape words from the terminals of the syntactic tree.
			var output_gen_options = output_gen_opt_list[j];

			if(resultsContainer){
				var settingsDisp = document.createElement('div');
				settingsDisp.innerText = "Creating tableau with GEN settings "+JSON.stringify(output_gen_options);
				settingsDisp.style.width = "400px";
				settingsDisp.style.fontStyle = "strong";
				resultsContainer.appendChild(settingsDisp);
				resultsContainer.appendChild(document.createElement('p'));
			}

			try{
				var candSet = GEN({}, 'a b c', output_gen_options);
			}
            catch(err){
				if(resultsContainer){
					var catErrDisp = document.createElement('div');
					catErrDisp.width = 300;
					var t = ["This tableau could not be created due to incorrect GEN settings.", "Gen categories:", JSON.stringify(output_gen_options), "Current prosodic hierarchy:", JSON.stringify(pCat)]
					for(var i in t){
						var x = document.createElement('p');
						x.innerText = t[i];
						x.style.width = "400px";
						catErrDisp.appendChild(x);
					}
					resultsContainer.appendChild(catErrDisp);
				}
				continue;
			}
            
			//Make the tableau using the makeTableau function (defined in tableauMaker.js)
		var tabl = makeTableau(candSet, window[consName], {showTones: output_gen_options.addTones, parens: myCategoryBrackets});//, ph}); ph object goes to GEN instead of to tableauMaker
			
			//Write the tableau to the screen and reveal it -- only uncomment this if you don't have too many tableaux!
			writeTableau(tabl, {});
			revealNextSegment();
			lastSegmentId++;
			
			//Add the tableau from the current stree to cumulative tableau that is being built in csvSegs.
            csvSegs.push(tableauToCsv(tabl, '\t', {noHeader: j}));
        }
		
		//Save the tableau as a tab-separated file, named after consName
        //saveTextAs(csvSegs.join('\n'),"tableau_"+consName+".tsv");
    }
	
	/*This function executes automatically when the page is reloaded. It calls all the other functions.*/
    function runDemo() {
	//Iterate over the different constraint sets. Make a tableau for each one.
		for(var i = 0; i<conNames.length; i++){
			makeTableauCsvs(conNames[i]);
		}
    }
    
    /*Utilities for saving files.*/
    function saveAs(blob, name) {
        var a = document.createElement("a");
        a.display = "none";
        a.href = URL.createObjectURL(blob);
        a.download = name;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
    }
   
    function saveTextAs(text, name) {
        saveAs(new Blob([text], {type: "text/csv", encoding: 'utf-8'}), name);
    }
	


</script>

</body>

</html>
